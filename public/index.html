<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Shooter 3D de Hordas</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #0b0f14; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans'; }
    #hud { position: fixed; inset: 0; pointer-events: none; color: #e8f0ff; }
    #score { position: absolute; top: 16px; left: 16px; font-weight: 700; letter-spacing: .5px; text-shadow: 0 1px 2px rgba(0,0,0,.6); }
    #health { position: absolute; top: 16px; right: 16px; text-align: right; }
    #bar { width: 200px; height: 10px; background: rgba(255,255,255,.15); border-radius: 999px; overflow: hidden; box-shadow: inset 0 0 0 1px rgba(255,255,255,.12); }
    #fill { height: 100%; width: 100%; background: linear-gradient(90deg, #51ff9c, #3bd1ff); }
    #wave { position: absolute; top: 44px; left: 16px; opacity: .9; font-size: 14px; }
    #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 18px; height: 18px; pointer-events: none; }
    #crosshair:before, #crosshair:after { content: ""; position: absolute; background: #e8f0ff; }
    #crosshair:before { left: 50%; top: 0; width: 2px; height: 100%; transform: translateX(-50%); }
    #crosshair:after { top: 50%; left: 0; width: 100%; height: 2px; transform: translateY(-50%); }
    #overlay { position: fixed; inset: 0; background: radial-gradient(1200px 600px at 50% -20%, rgba(59,209,255,.2), transparent 60%), linear-gradient(#0b0f14, #090c10 60%); display: grid; place-items: center; }
    .card { pointer-events: auto; width: min(560px, 94vw); background: rgba(255,255,255,.06); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,.12); border-radius: 20px; box-shadow: 0 10px 40px rgba(0,0,0,.35); padding: 24px; color: #e8f0ff; }
    .title { font-size: 28px; font-weight: 800; margin: 0 0 6px; }
    .subtitle { opacity: .85; margin: 0 0 16px; }
    .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 12px 18px; font-size: 14px; margin: 14px 0 10px; }
    .controls div { opacity: .9; }
    .kbd { display: inline-grid; place-items: center; min-width: 26px; padding: 2px 6px; border-radius: 8px; background: rgba(255,255,255,.12); border: 1px solid rgba(255,255,255,.18); box-shadow: inset 0 -2px 0 rgba(255,255,255,.08); font-weight: 700; margin: 0 2px; }
    .btn { display: inline-flex; align-items: center; justify-content: center; gap: 10px; border: 1px solid rgba(255,255,255,.18); background: linear-gradient(#66e0ff,#3bd1ff); color: #00131c; font-weight: 900; text-transform: uppercase; letter-spacing: .6px; border-radius: 14px; padding: 12px 18px; cursor: pointer; user-select: none; box-shadow: 0 8px 24px rgba(59,209,255,.35); }
    .btn.secondary { background: rgba(255,255,255,.06); color: #e8f0ff; box-shadow: none; }
    .row { display:flex; gap:12px; align-items:center; justify-content:flex-start; flex-wrap: wrap; }
    .small { font-size: 12px; opacity: .8; }
    #msg { position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,.35); border: 1px solid rgba(255,255,255,.14); padding: 10px 14px; border-radius: 999px; font-size: 13px; opacity: 0; transition: opacity .25s; }
    #msg.show { opacity: 1; }
  </style>
</head>
<body>
  <div id="hud">
    <div id="score">Puntos: <span id="scoreVal">0</span></div>
    <div id="wave">Oleada: <span id="waveVal">1</span></div>
    <div id="health">
      Vida: <span id="hpText">100</span>
      <div id="bar"><div id="fill"></div></div>
    </div>
    <div id="crosshair"></div>
    <div id="msg">Pulsa para disparar • R para recargar</div>
  </div>

  <div id="overlay">
    <div class="card">
      <h1 class="title">Shooter 3D de Hordas</h1>
      <p class="subtitle">Versión Electron. Sobrevive tantas oleadas como puedas.</p>
      <div class="controls">
        <div><span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span> Mover</div>
        <div><span class="kbd">Ratón</span> Mirar</div>
        <div><span class="kbd">Click</span> Disparar</div>
        <div><span class="kbd">R</span> Recargar</div>
        <div><span class="kbd">Espacio</span> Saltar</div>
        <div><span class="kbd">Shift</span> Sprint</div>
      </div>
      <div class="row">
        <button class="btn" id="startBtn">Comenzar</button>
        <button class="btn secondary" id="lowBtn" title="Reduce efectos">Modo Rendimiento</button>
      </div>
      <p class="small">Sugerencia: pantalla completa con audio. Móvil no soportado.</p>
    </div>
  </div>

  <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
  <script>
    // --- Controles mínimos tipo Pointer Lock (sin dependencias) ---
    class MinimalPointerLockControls {
      constructor(camera, domElement){
        this.camera = camera; this.domElement = domElement; this.isLocked = false;
        this._euler = new THREE.Euler(0,0,0,'YXZ'); this._PI_2 = Math.PI/2; this._sens = 0.0026;
        this.yawObject = new THREE.Object3D(); this.pitchObject = new THREE.Object3D();
        this.pitchObject.add(this.camera); this.yawObject.add(this.pitchObject);
        this._onMove = (e)=>{
          if(!this.isLocked) return;
          const mx = e.movementX||0, my = e.movementY||0;
          this._euler.setFromQuaternion(this.pitchObject.quaternion);
          this._euler.y -= mx * this._sens; this._euler.x -= my * this._sens;
          this._euler.x = Math.max(-this._PI_2, Math.min(this._PI_2, this._euler.x));
          this.pitchObject.quaternion.setFromEuler(this._euler);
          this.yawObject.rotation.y = this._euler.y;
        };
        this._onPLC = ()=>{
          const locked = (document.pointerLockElement === this.domElement);
          if (locked && !this.isLocked){ this.isLocked = true; this.dispatchEvent({type:'lock'}); }
          else if (!locked && this.isLocked){ this.isLocked = false; this.dispatchEvent({type:'unlock'}); }
        };
        document.addEventListener('pointerlockchange', this._onPLC);
        this.domElement.addEventListener('mousemove', this._onMove);
      }
      getObject(){ return this.yawObject; }
      getDirection(t){ const v=t||new THREE.Vector3(); v.set(0,0,-1).applyQuaternion(this.pitchObject.quaternion).applyAxisAngle(new THREE.Vector3(0,1,0), this.yawObject.rotation.y); return v.normalize(); }
      lock(){ this.domElement.requestPointerLock(); }
      unlock(){ document.exitPointerLock(); }
      addEventListener(type, fn){ (this._ls||(this._ls={}))[type]=fn; }
      dispatchEvent(ev){ if(this._ls && this._ls[ev.type]) this._ls[ev.type](ev); }
    }

    const state = { running:false, score:0, wave:1, hp:100, maxHP:100, ammo:12, maxAmmo:12, reserve:72, reloading:false, lowFX:false };
    const scoreVal = document.getElementById('scoreVal');
    const waveVal = document.getElementById('waveVal');
    const hpText = document.getElementById('hpText');
    const fill = document.getElementById('fill');
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('startBtn');
    const lowBtn = document.getElementById('lowBtn');
    const msg = document.getElementById('msg');

    function updateHUD(){ scoreVal.textContent=state.score; waveVal.textContent=state.wave; hpText.textContent=Math.max(0,Math.round(state.hp)); fill.style.width=Math.max(0,(state.hp/state.maxHP)*100)+'%'; }

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x16202b);
    scene.fog = new THREE.Fog(0x16202b, 50, 500);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 500);
    camera.position.set(0,1.6,3);

    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);
    renderer.domElement.style.cursor='crosshair';

    const hemi = new THREE.HemisphereLight(0x99ccff, 0x223344, 0.8); scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(5,10,2); scene.add(dir);

    const floorGeo = new THREE.PlaneGeometry(400,400,40,40); floorGeo.rotateX(-Math.PI/2);
    const floorMat = new THREE.MeshStandardMaterial({ color:0x1f2937, metalness:0, roughness:1 });
    const floor = new THREE.Mesh(floorGeo, floorMat); scene.add(floor);
    const grid = new THREE.GridHelper(400,80,0x193244,0x14222e); grid.material.transparent=true; grid.material.opacity=.35; scene.add(grid);

    // Cubo de prueba
    const testCube = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({ color:0x3bd1ff }));
    testCube.position.set(0,0.5,-4); camera.add(testCube); scene.add(camera);

    const controls = new MinimalPointerLockControls(camera, renderer.domElement);
    scene.add(controls.getObject());

    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const worldUp = new THREE.Vector3(0,1,0);
    let canJump = false;
    const keys = { forward:false, backward:false, left:false, right:false, sprint:false };

    function onKey(e, down){
      switch(e.code){
        case 'KeyW': keys.forward=down; break;
        case 'KeyS': keys.backward=down; break;
        case 'KeyA': keys.left=down; break;
        case 'KeyD': keys.right=down; break;
        case 'ShiftLeft': keys.sprint=down; break;
        case 'Space': if(down && canJump){ velocity.y = 6; canJump=false; } break;
        case 'KeyR': if(down) reload(); break;
      }
    }
    document.addEventListener('keydown', e=>onKey(e,true));
    document.addEventListener('keyup', e=>onKey(e,false));

    const shootAudio = new Audio();
    shootAudio.src = 'data:audio/wav;base64,UklGRjQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABYAAAClAAAAPwAA';

    const raycaster = new THREE.Raycaster();
    let lastShot = 0; const fireRate = 130;
    function showMsg(text){ msg.textContent = text; msg.classList.add('show'); clearTimeout(showMsg._t); showMsg._t = setTimeout(()=>msg.classList.remove('show'), 1600); }
    function hideMsg(){ msg.classList.remove('show'); }

    function shoot(){
      if(!state.running || state.reloading) return;
      const now = performance.now(); if(now-lastShot<fireRate) return;
      if(state.ammo<=0){ showMsg('Sin balas — pulsa R'); return; }
      lastShot=now; state.ammo--; shootAudio.currentTime=0; shootAudio.play().catch(()=>{});
      muzzleFlash();
      raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
      const intersects = raycaster.intersectObjects(enemies.map(e=>e.mesh), false);
      if(intersects.length){
        const hit = intersects[0]; const enemy = enemies.find(e=>e.mesh===hit.object);
        if(enemy){ enemy.hp -= 50; hitEffect(hit.point); if(enemy.hp<=0){ removeEnemy(enemy); state.score+=10; } else { knockback(enemy, camera.position, 1.4); } }
      } else {
        const point = camera.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(10));
        hitEffect(point);
      }
      updateHUD();
    }
    function reload(){
      if (state.reloading || state.ammo===state.maxAmmo || state.reserve<=0) return;
      state.reloading = true; showMsg('Recargando…');
      setTimeout(()=>{
        const need = state.maxAmmo - state.ammo;
        const take = Math.min(need, state.reserve);
        state.ammo += take; state.reserve -= take;
        state.reloading = false; hideMsg();
      }, 700);
    }

    const tempVec = new THREE.Vector3();
    function muzzleFlash(){ if(state.lowFX) return; const g=new THREE.SphereGeometry(0.05,6,6); const m=new THREE.MeshBasicMaterial({color:0xffee88}); const s=new THREE.Mesh(g,m); s.position.copy(camera.position).add(camera.getWorldDirection(tempVec).multiplyScalar(0.4)); scene.add(s); setTimeout(()=>scene.remove(s),50); }
    function hitEffect(point){ if(state.lowFX) return; const g=new THREE.SphereGeometry(0.06,6,6); const m=new THREE.MeshBasicMaterial({color:0x66e0ff}); const p=new THREE.Mesh(g,m); p.position.copy(point); scene.add(p); setTimeout(()=>scene.remove(p),120); }
    function knockback(enemy, from, strength){ const d = enemy.mesh.position.clone().sub(from).normalize(); enemy.vel.add(d.multiplyScalar(2*strength)); }

    const enemies = [];
    const enemyGeo = new THREE.BoxGeometry(0.8,1.2,0.5);
    const enemyMat = new THREE.MeshStandardMaterial({ color:0x7fffd4, emissive:0x0, metalness:0.1, roughness:0.7 });
    function spawnEnemy(){
      const mesh = new THREE.Mesh(enemyGeo, enemyMat.clone());
      mesh.material.color.offsetHSL((Math.random()*0.2)-0.1, 0, 0);
      const radius = 18 + Math.random()*18; const angle = Math.random()*Math.PI*2;
      mesh.position.set(Math.cos(angle)*radius, 0.6, Math.sin(angle)*radius);
      scene.add(mesh); enemies.push({ mesh, hp: 100, vel: new THREE.Vector3() });
    }
    function removeEnemy(enemy){ scene.remove(enemy.mesh); const i=enemies.indexOf(enemy); if(i!==-1) enemies.splice(i,1);
      if(!state.lowFX){ const g=new THREE.SphereGeometry(0.25,10,10); const m=new THREE.MeshBasicMaterial({color:0x3bd1ff}); const s=new THREE.Mesh(g,m); s.position.copy(enemy.mesh.position); scene.add(s); setTimeout(()=>scene.remove(s),180); } }

    let nextWaveTime = 0;
    function updateWaves(time){
      if (time > nextWaveTime){
        const count = Math.min(6 + state.wave*2, 60);
        for(let i=0;i<count;i++) spawnEnemy();
        showMsg(`¡Oleada ${state.wave}!`);
        nextWaveTime = time + 25000; state.wave++; updateHUD();
      }
    }

    function updateEnemyAI(delta){
      const playerPos = controls.getObject().position;
      for(const e of enemies){
        tempVec.copy(playerPos).sub(e.mesh.position); tempVec.y=0;
        const dist = tempVec.length() || 0.0001; tempVec.normalize();
        const speed = THREE.MathUtils.clamp(2.2 + (Math.random()*0.2), 2.2, 2.6);
        e.vel.add(tempVec.multiplyScalar(speed*delta)); e.vel.multiplyScalar(0.92);
        e.mesh.position.add(e.vel.clone().multiplyScalar(delta)); e.mesh.lookAt(playerPos.x, e.mesh.position.y, playerPos.z);
        if (dist < 1.2){ state.hp -= 14*delta; }
      }
      if (state.hp <= 0) gameOver();
    }
    function gameOver(){ state.running=false; showOverlay('Game Over', `Puntaje: ${state.score}`, true); }

    function showOverlay(title, subtitle, showRestart){ overlay.style.display='grid'; overlay.querySelector('.title').textContent=title; overlay.querySelector('.subtitle').innerHTML=subtitle; startBtn.textContent = showRestart ? 'Reintentar' : 'Comenzar'; }
    function hideOverlay(){ overlay.style.display='none'; }

    startBtn.addEventListener('click', ()=>{
      state.running = true; state.score=0; state.wave=1; state.hp=state.maxHP; state.ammo=state.maxAmmo; state.reserve=72; state.reloading=false;
      updateHUD(); hideOverlay();
      try { controls.lock(); } catch(e){}
      for(const e of [...enemies]) removeEnemy(e); nextWaveTime = 0;
    });
    lowBtn.addEventListener('click', ()=>{ state.lowFX=!state.lowFX; lowBtn.textContent = state.lowFX ? 'FX mínimos ✓' : 'Modo Rendimiento'; showMsg(state.lowFX ? 'Efectos reducidos' : 'Efectos restaurados'); });
    controls.addEventListener('lock', ()=>{ showMsg('Apunta y dispara'); });
    controls.addEventListener('unlock', ()=>{ showMsg('Haz clic en el juego para capturar el ratón'); });

    renderer.domElement.addEventListener('mousedown', e=>{ if(e.button===0) shoot(); });

    const clock = new THREE.Clock();
    function updatePlayer(delta){
      const speed = (keys.sprint?7.2:4.2);
      direction.set(0,0,0);
      if (keys.forward) direction.z -= 1;
      if (keys.backward) direction.z += 1;
      if (keys.left) direction.x -= 1;
      if (keys.right) direction.x += 1;
      direction.normalize();

      if (controls.isLocked){
        const forward = new THREE.Vector3(); controls.getDirection(forward); forward.y=0; forward.normalize();
        const right = new THREE.Vector3().crossVectors(forward, worldUp).multiplyScalar(-1);
        velocity.x += (right.x * direction.x + forward.x * direction.z) * speed * delta * 30;
        velocity.z += (right.z * direction.x + forward.z * direction.z) * speed * delta * 30;
      }
      velocity.y -= 9.8 * delta * 2.2;
      const damping = Math.pow(0.92, delta*60);
      velocity.x *= damping; velocity.z *= damping;

      const obj = controls.getObject();
      obj.position.x += velocity.x * delta * 0.05;
      obj.position.z += velocity.z * delta * 0.05;
      obj.position.y += velocity.y * delta * 0.05;

      if (obj.position.y < 1.6){ velocity.y = 0; obj.position.y = 1.6; canJump = true; }
    }

    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function animate(){
      requestAnimationFrame(animate);
      const delta = clock.getDelta(); const elapsed = performance.now();
      if (state.running){ updatePlayer(delta); updateEnemyAI(delta); updateWaves(elapsed); }
      renderer.render(scene, camera);
    }
    animate();
    window.addEventListener('keydown', e=>{ if(e.code==='Space' && e.target===document.body) e.preventDefault(); }, {passive:false});
  </script>
</body>
</html>
